
import java.util.Random;
import java.io.*;
import java.util.*;//ArrayListのために追加

/*
講義資料とこのソースのコメントをよく読み，
仕様にあったものにする事！！
*/


/*
ｰCardsクラスの仕様(クラス外から見えるもの)ｰ
数字の書かれたカードのような概念を持つクラス．
「カード」なので，以下で説明する「位置」や「範囲」などの値は，1枚目から数える．
つまり，0枚目は存在しない．
また，以下では説明しないが，範囲外の値を受け取った場合はエラーを表示する．


Cards内で保持するカード群num
(ArrayList<Integer>型，ただしprotected)

==コンストラクタ
引数無しの場合：要素を持たないnumを生成．
ArrayList<Integer>型の1引数：引数の要素をnumへコピー(代入ではない)して生成．

==add
int型1引数の場合：numの最後へ引数の値を追加．
int型2引数の場合：第一引数で指定された位置へ第二引数の値を追加．

==clear
引数無し，numを全削除．

==remove
int型1引数の場合：引数の値で指定した位置の要素を削除．
int型2引数の場合：int型2引数を受け取り，第一引数から第二引数までの範囲の位置の要素を削除．


==getInd，getFirst，getLast
今まで同様です．

==size
引数無し，要素数を返す．

==sumShow
引数無し，生成されたCardsクラスの数を返すクラスメソッド．

*/


/*
このクラスのメソッドは全てクラスメソッドにする事．
つまり，どれもShuffleSort.ｰで呼び出せるようにする事．
*/
class ShuffleSort{

	/* 
	個数，最小値，最大値を受け取り，ArrayList<Integer>型を返すmakeRnd
	今まで通り，最小値ｰ最大値の範囲の乱数を個数分生成する．
	 */
	public ArrayList<Integer> makeRnd(int num, int min, int max){
		Random rnd = new Random();
		ArrayList<Integer> n = new ArrayList<Integer>();
		for (int i = 0; i<=num ;i++){
			n.add(rnd.nextInt((max - min + 1))+min);
		}
		return n;
	}

	/* 
	最小値，最大値を受け取り，ArrayList<Integer>型を返すmakeSequence
	今まで通り，最小値ｰ最大値の範囲連続値を生成する．
	 */
	public ArrayList<Integer> makeSequence(int min, int max){
		ArrayList<Integer> n = new ArrayList<Integer>();
		for (int i = 0;i<=max - min;i++){
			n.add(min + i);
		}	
		return n;
	}


	/* 
	ArrayList<Integer>型を受け取り，それを昇順及び降順バブルソートするvoid型のbubbleGreater，bubbleLess，
	同様にシャッフルするshuffle
	クラスが引数なので，そのまま引数の変数をいじればOKですね？
	 */
	public static void bubbleGreater(ArrayList<Integer> n){
		for (int j = 0; j<n.size()  ;j++){
			for (int i = 0; i<n.size()-1;i++){
				if (n.get(i) > n.get(i+1)){
					int tmp = n.get(i);
					n.set(i,n.get(i+1));
					n.set(i+1,tmp);
				}
			}
		}
	}

	public static void bubbleLess(ArrayList<Integer> n){
		for (int j = 0; j<n.size();  j++){
			for (int i = 0; i<n.size()-1;i++){
				if (n.get(i) < n.get(i+1)){
					int tmp = n.get(i);
					n.set(i,n.get(i+1));
					n.set(i+1,tmp);
				}
			}
		}
	}

	public static void shuffle(ArrayList<Integer> n){
		Random rnd = new Random();
		for (int i=0;i<n.size();i++){
			int r = rnd.nextInt(n.size());
			
			int tmp = n.get(i);
			n.set(i,n.get(r));
			n.set(r,tmp);
		}

	}

}


//MyCardsクラスは，Cardsクラスを継承する
class MyCards extends Cards {
	/*
	int型変数mySumをクラス変数として宣言せよ．
	ただし，クラス外からアクセス不可にする事．
	MyCardsクラスが生成される度に1加算する事．
	*/

	/*
	MyCardsクラスのコンストラクタを定義せよ．

	ｰ引数無しの場合ｰ
	1枚もカードがないまま生成．
	*/
	private static int mySum = 0; 
	public MyCards(){
		//	num = new ArrayList<Integer>();
		mySum++;
	}
	/*
	ｰ引数がint型3つの場合ｰ
	引数を個数，最小値，最大値の順に受け取り，
	最小値から最大値の範囲の指定された個数の乱数をスーパークラスCards内に用意し，その内容を表示せよ．
	ただし，ShuffleSortクラスのクラスメソッドを活用！！

	ｰ引数がint型2つの場合ｰ
	引数を最小値，最大値の順に受け取り，
	Kadai4_2やKadai5の後半のように，
	最小値から最大値まで連続値をスーパークラスCards内に用意し，その内容を表示せよ．
	ただし，ShuffleSortクラスのクラスメソッドを活用！！

	*/
	public MyCards(int n,int min,int max){
		this();
		Random rnd = new Random();
		for (int i=0;i<n;i++){
			num.add(rnd.nextInt(max - min +1)+min);
		}
		this.show();
	}

	//	public MyCards(int min,int max){
	//	this();
	//	for (int i=0;i<=max - min;i++){
	//		num.add(i+min);
	//	}
	//	this.show();
	//}

	/*
	void型のshuffle，bubbleGreater，bubbleLessを定義せよ．
	と言っても，ShuffleSortクラスのクラスメソッドに渡すだけ．
	*/
	public void shuffle(){
		ShuffleSort.shuffle(num);
	}
	public void bubbleGreater(){
		ShuffleSort.bubbleGreater(num);
	}
	public void bubbleLess(){
		ShuffleSort.bubbleLess(num);
	}

	/*
	void型のshowを3パターン定義せよ．
	ただしいずれの場合も，要素数が0だった場合は
	「要素がありません．」
	と表示する事．
	
	ｰ引数無しの場合ｰ
	全ての要素を表示．

	ｰint型1引数の場合ｰ
	指定された位置の要素を表示．
	ただし，指定した位置が0以下であったり，要素数より大きかった場合は，
	「指定された位置○は範囲外です．」
	と表示する事．

	ｰint型2引数の場合ｰ
	第一引数を範囲の初め，第二引数を範囲の終わりとし，その範囲の要素を表示．
	ただし，指定した位置が0以下であったり，要素数より大きかったり，第一引数>第二引数だった場合は，
	「指定された位置○ｰ○は範囲外です．」
	と表示する事．
	*/


	public void show(){
		if (num.size() != 0){
		for (int i=0;i<num.size()-1;i++){
			System.out.print(num.get(i)+",");
		}
		System.out.println(num.get(num.size()-1));
		
		}else {
			System.out.println("要素がありません");
		}
	}

	public void show(int n){
		if (num.size() <= n){
			System.out.println("指定された要素"+n+"は範囲外です");
		}else {
			System.out.println("指定した要素は"+num.get(n-1)+"です");
		}
	}

	public void show(int min,int max){
		for (int i=min;i<max;i++){
			System.out.print(num.get(i-1)+",");
		}
		System.out.println(num.get(max-1));
	}
	/*
	int型2引数を受け取り，MyCards型(つまり自クラス)を返すpick
	第一引数を範囲の初め，第二引数を範囲の終わりとし，その範囲の要素を取り出して新しいMyCards型クラスを生成し，返す
	当然，「取り出す」ので，取り出された要素は削除する．
	ただし，自クラスの要素数が0だった場合は
	「要素がありません．」，
	指定した位置が0以下であったり，要素数より大きかったり，第一引数>第二引数だった場合は，
	「指定された位置○ｰ○は範囲外です．」
	と表示する事．
	*/
	public MyCards pick(int first,int last){
		MyCards card = new MyCards();
		if (num.size() != 0){

			if (first > 0 && last <=num.size()){

				//	for (int i=0;i<num.size();i++){
				//	if (i == first-1){
				//		//i = last - 1;
				//		card.add(num.get(i));
				//		num.remove(i);
				//	}else if (i >= last){
						//card.num.add(num.get(i));
				//		num.set(first-1+i,num.get(i));
				//	}

				//}
			}else {
				System.out.println("指定された位置"+first+"-"+last+"は範囲外です");
			}
		}else{
			System.out.println("要素が存在しません");
		}
		
		return card;
	}
	
	
	/*
	  クラス変数my_sumを表示する，
	引数無し，void型のクラスメソッドmySumShowの定義．
	*/
	public static void mySumShow(){
		System.out.println("MyCardsは"+mySum+"回呼ばれました");
	}

	/////////////////////////////////////////////////////////
	////
	////  Kadai10からの追加部分
	////
	///////////////////////////////////////////////////////





	static int win=0;
	static int rose=0;
	static int draw=0;
	
	static int min = 0;
	static int max = 0;
	int[] cards;

	public static void win_rose(int I,int You){
		System.out.println("あなたが出したカードは["+I+"]です。相手の出したカードは["+You+"]です。");
		if (I > You){
			System.out.println("あなたの勝ちです!!");
			win++;
		}else if(You > I){	
			System.out.println("コンピューターの勝ちです!!");
			rose++;
		}else if (You == I){	
			System.out.println("引き分けです!!");
			draw++;	
		}
		System.out.println("現在"+win+"勝"+rose+"敗"+draw+"分けです。");

	}

	public MyCards(int pmin,int pmax){
		min = pmin;
		max = pmax;		
		cards = new int[max+1];
		CreateCardList();
		this.CardList();
	}

	public void CardList(){
		int i;		
		for (i = min;i<max;i++){
			System.out.print(i + ",");
		}
		System.out.println(i+"です");
	}

	public void CardsShow(MyCards my){
		int i = 0;

		for (i=0;i<my.cards.length-1 && my.cards[i+1] != -1;i++){
			System.out.print(my.cards[i]+",");
		}
		System.out.println(my.cards[i]+"です。");
	}

	public void CreateCardList(){
		Random rnd = new Random();
		for (int i = 0;i<max+1;i++){
			cards[i] = rnd.nextInt(10);
		}
	}

	public void shiftNull(){
		for (int i = 0;i<cards.length-1;i++){
			if (cards[i] == -1){
				int tmp = cards[i+1];
				cards[i+1] = cards[i];
				cards[i] = tmp;
			}
		}
	}
	public void clear(int ch){
		cards[ch] = -1;
		this.shiftNull();
	}

}


class Kadai12 {
	public static void main(String[] args) throws IOException
	{	/* BufferedReaderのインスタンス化 */
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		/* MyCardsクラスをcards2としてインスタンス化 */
		MyCards[] cards = new MyCards[2];
		
		int i;
		for (i=0;i<2;i++){
			cards[i] = new MyCards(0,10);
			//			cards[i].CardList();
		}
		System.out.println("あなたの手持ちのカードは");
		cards[0].CardsShow(cards[0]);
		
		for (int turn=0;turn < 10;turn++){
			
			System.out.println("何番目のカードを出しますか？");
			int[] choose = new int[2];
			
			choose[0] = Integer.parseInt(br.readLine());
			
			Random rnd = new Random();
			choose[1] = rnd.nextInt(10);

			MyCards.win_rose(cards[0].cards[choose[0]],cards[1].cards[choose[1]]);
			
			for (i = 0;i<cards.length;i++){
				cards[i].clear(choose[i]);
			}

			cards[0].CardsShow(cards[0]);
		}
	}
}
